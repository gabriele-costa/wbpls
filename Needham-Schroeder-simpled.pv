free c : channel.
free dejam_chan : channel.

type bitset.
type mask.

fun mk_mask(bitset, nat) : mask.
reduc forall b:bitset, i:nat; maskNat(mk_mask(b,i)) = i.
reduc forall b:bitset, i:nat; maskBitset(mk_mask(b,i)) = b.

pred leq(mask, mask).
clauses forall m1:mask, m2:mask; (maskBitset(m1) = maskBitset(m2)) && (maskNat(m1) = 0) -> leq(m1, m2);
        forall m1:mask, m2:mask; leq(mk_mask(maskBitset(m1), maskNat(m1)-1), mk_mask(maskBitset(m2), maskNat(m2)-1)) -> leq(m1, m2).

fun wat(bitstring, mask) : bitstring.
reduc forall b:bitstring, m:mask; watMask(wat(b,m)) = m.
reduc forall b:bitstring, m:mask; watBitstring(wat(b,m)) = b.


fun jam(bitstring, mask) : bitstring.
reduc forall b:bitstring, m:mask; jamMask(jam(b,m)) = m.
reduc forall b:bitstring, m:mask; jamBitstring(jam(b,m)) = b.


(* dejammer *)
let processDeJam() =
  in(dejam_chan, m: bitstring);
  let q = jamMask(m) in
  let p = watMask(jamBitstring(m)) in
  let m1 = watBitstring(jamBitstring(m)) in
  if leq(q, p) then out(dejam_chan, m1).


fun senc(bitstring, bitstring): bitstring.
reduc forall x: bitstring, y: bitstring; sdec(senc(x, y), y)= x.

free secretANa, secretANb, secretBNa, secretBNb :bitstring [private].

query attacker(secretANa);
	  attacker(secretANb);
	  attacker(secretBNa);
	  attacker(secretBNb).

(*Alice*)
let processA(NA : mask, NB : mask)=
	new Na: bitstring;
	out(c, jam(wat(Na, NA), NA));
	in(c, m: bitstring);
  out(dejam_chan, m);
  in(dejam_chan, (Naa : bitstring, NX : bitstring));
  if Na = Naa then
	out(c, jam(wat(NX, NA),NA));
	out(c, senc(secretANa, Na));
	out(c, senc(secretANb, NX)).

(*Bob*)
let processB(NA:mask, NB : mask)=
	in(c, m: bitstring);
  out(dejam_chan, m);
  in(dejam_chan, NY : bitstring);
	new Nb: bitstring;
	out(c, jam(wat((NY,Nb), NB),NB));
	in(c, m3: bitstring);
  out(dejam_chan, m3);
  in(dejam_chan, Nbb : bitstring);
  if Nb = Nbb then
	out(c, senc(secretBNa, NY));
	out(c, senc(secretBNb, Nb)).

(*Main*)
process
	new NA: mask;
	new NB: mask;
	((!processA(NA, NB)) | (!processB(NA, NB)) | (!processDeJam()))
