free c : channel.

type bitset.
type mask.



(* se p <= q restituisce q, altrimenti fallisce *)
pred leq(mask, mask).
clauses forall m1:mask; leq(m1, m1);
        forall m1:mask, m2:mask, m3:mask; leq(m1, m2) && leq(m1, m3) -> leq(m1, m3).

fun wat(bitstring, mask) : bitstring.
equation forall m:bitstring, n:mask; wat(m, n) = m.



fun jam(bitstring, bool) : bitstring.
reduc forall m:bitstring, p:mask, q:mask; djam(jam(wat(m,p),q),leq(q,p)) = m.
(* reduc forall m:bitstring, n:bitset; djam(jam(m, mk_mask(n,0))) = m. *)



fun senc(bitstring, bitstring): bitstring.
reduc forall x: bitstring, y: bitstring; sdec(senc(x, y), y)= x.

free secretANa, secretANb, secretBNa, secretBNb :bitstring [private].

query attacker(secretANa);
	  attacker(secretANb);
	  attacker(secretBNa);
	  attacker(secretBNb).

(*Alice*)
let processA(NA : mask, NB : mask)=
	new Na: bitstring;
	out(c, jam(wat(Na, NA), NA));
	in(c, m: bitstring);
	let (= Na, NX: bitstring) = djam(m, true) in
	out(c, jam(wat(NX, NA),NA));
	out(c, senc(secretANa, Na));
	out(c, senc(secretANb, NX)).

(*Bob*)
let processB(NA:mask, NB : mask)=
	in(c, m: bitstring);
	let NY: bitstring = djam(m, NA) in
	new Nb: bitstring;
	out(c, jam(wat((NY,Nb), NB),NB));
	in(c, m3: bitstring);
	if Nb= djam(m3, NA) then
	out(c, senc(secretBNa, NY));
	out(c, senc(secretBNb, Nb)).

(*Main*)
process
	new NA: mask;
	new NB: mask;
	((!processA(NA, NB)) | (!processB(NA, NB)))
