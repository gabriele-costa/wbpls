free c : channel.

type bitset.
type mask.

fun mk_mask(bitset,nat) : mask.


fun wat(bitstring, mask) : bitstring.
equation forall m:bitstring, n:mask; wat(m, n) = m.


fun jam(bitstring, mask) : bitstring.
reduc forall m:bitstring, n:mask; djam(jam(wat(m,n),n), n) = m.
(* reduc forall m:bitstring, n:bitset; djam(jam(m, mk_mask(n,0))) = m. *)


(*
type pkey.
type skey.

fun pk(skey): pkey.
fun aenc(bitstring, pkey): bitstring.
reduc forall x: bitstring, y:skey; adec(aenc(x, pk(y)), y)= x.


type spkey.
type sskey.

fun spk(sskey): spkey.
fun sign(bitstring, sskey): bitstring.
reduc forall x: bitstring, y: sskey; getmess(sign(x, y))= x.
reduc forall x: bitstring, y: sskey; checksign(sign(x, y), spk(y))= x.
*)



fun senc(bitstring, bitstring): bitstring.
reduc forall x: bitstring, y: bitstring; sdec(senc(x, y), y)= x.

(*
event beginBparam(pkey).
event endBparam(pkey).
event beginAparam(pkey).
event endAparam(pkey).

query x: pkey; inj-event(endBparam(x)) ==> inj-event(beginBparam(x)).
query x: pkey; inj-event(endAparam(x)) ==> inj-event(beginAparam(x)).
*)

free secretANa, secretANb, secretBNa, secretBNb :bitstring [private].

query attacker(secretANa);
	  attacker(secretANb);
	  attacker(secretBNa);
	  attacker(secretBNb).

(*Alice进程*)
let processA(NA : mask, NB : mask)=
	new Na: bitstring;
	out(c, jam(wat(Na, NA), NA));
	in(c, m: bitstring);
	let (= Na, NX: bitstring) = djam(m, NB) in
	out(c, jam(wat(NX, NA),NA));
	out(c, senc(secretANa, Na));
	out(c, senc(secretANb, NX)).
	
(*Bob进程*)
let processB(NA:mask, NB : mask)=
	in(c, m: bitstring);
	let NY: bitstring = djam(m, NA) in
	new Nb: bitstring;
	out(c, jam(wat((NY,Nb), NB),NB));
	in(c, m3: bitstring);
	if Nb= djam(m3, NA) then 
	out(c, senc(secretBNa, NY));
	out(c, senc(secretBNb, Nb)).
	
(*主函数*)
process
	new NA: mask; 
	new NB: mask; 	
	((!processA(NA, NB)) | (!processB(NA, NB)))