set traceDisplay = long.

free c : channel.
free dejam_chan : channel [private].
free jam_chan : channel [private].

const alice : bitstring.
const bob : bitstring.
const eve : bitstring.
const dummy : bitstring.

type bitset.
type mask.

const null : bitset.

fun mk_mask(bitset, nat) : mask.
reduc forall b:bitset, i:nat; maskNat(mk_mask(b,i)) = i.
reduc forall b:bitset, i:nat; maskBitset(mk_mask(b,i)) = b.

pred leq(mask, mask).
clauses forall m1:mask, m2:mask; (maskBitset(m1) = maskBitset(m2)) && (maskNat(m1) = 0) -> leq(m1, m2);
        forall m1:mask, m2:mask; leq(mk_mask(maskBitset(m1), maskNat(m1)-1), mk_mask(maskBitset(m2), maskNat(m2)-1)) -> leq(m1, m2).

fun wat(bitstring, mask) : bitstring.
reduc forall b:bitstring, m:mask; watMask(wat(b,m)) = m.
reduc forall b:bitstring, m:mask; watBitstring(wat(b,m)) = b.

fun jam(bitstring, mask) : bitstring.
reduc forall b:bitstring, m:mask; jamMask(jam(b,m)) = m [private].
reduc forall b:bitstring, m:mask; jamBitstring(jam(b,m)) = b [private].
reduc forall b:bitstring, m:mask; jamAtkBitstring(jam(b,mk_mask(null, 0))) = b.

(* dejammer *)
let processDeJam() =
  in(dejam_chan, m: bitstring);
  let q = jamMask(m) in
  let p = watMask(jamBitstring(m)) in
  let m1 = watBitstring(jamBitstring(m)) in
    if leq(q, p) then out(dejam_chan, m1).

(* position *)
(* pred inRangeAtk(bitstring).
clauses forall a : bitstring; a = alice -> inRangeAtk(a);
        forall a : bitstring; a = bob -> inRangeAtk(a). *)

(* jammer *)
let processJam() =
  in(jam_chan, ((b: bitstring, m:mask), r : bitstring));
ifdef('InRange','out(c, jam(b, m)).')
ifndef('InRange','out(c, jam(b, mk_mask(null, 0))).')

(* if inRangeAtk(r) then
    out(c, jam(b, m))
  else
    out(c, jam(b, mk_mask(null, 0))). *)

fun senc(bitstring, bitstring): bitstring.
reduc forall x: bitstring, y: bitstring; sdec(senc(x, y), y)= x.

free secretANa, secretANb, secretBNa, secretBNb :bitstring [private].

query attacker(secretANa);
	  attacker(secretANb);
	  attacker(secretBNa);
	  attacker(secretBNb).

(*Alice*)
let processA(NA : mask, NB : mask)=
	new Na: bitstring;
	out(jam_chan, ((wat(Na, NA), NA), bob));
	in(c, m: bitstring);
  out(dejam_chan, m);
  in(dejam_chan, (Naa : bitstring, NX : bitstring));
  if Na = Naa then
	out(jam_chan, ((wat(NX, NA),NA), bob));
	out(c, senc(secretANa, Na));
	out(c, senc(secretANb, NX)).

(*Bob*)
let processB(NA:mask, NB : mask)=
	in(c, m: bitstring);
  out(dejam_chan, m);
  in(dejam_chan, NY : bitstring);
	new Nb: bitstring;
	out(jam_chan, ((wat((NY,Nb), NB),NB), alice));
	in(c, m3: bitstring);
  out(dejam_chan, m3);
  in(dejam_chan, Nbb : bitstring);
  if Nb = Nbb then
	out(c, senc(secretBNa, NY));
	out(c, senc(secretBNb, Nb)).

(*Main*)
process
	new NA: mask;
	new NB: mask;
	((!processA(NA, NB)) | (!processB(NA, NB)) | (!processJam()) | (!processDeJam()))
